{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { getCellId } from './cells.js';\nimport { sortStates } from '../state/sortStates.js';\n\n/**\n * Compare two primitives to determine which comes first. Initially, this method\n * will try and figure out if both entries are the same type. If so, it will\n * apply the default sort algorithm for those types. Otherwise, it defaults to a\n * string conversion.\n *\n * @param {number|string} a\n * @param {number|string} b\n * @param {string} locale\n * @returns {number}\n */\nconst compare = function (a, b) {\n  let locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n  // prevent multiple null values in one column (sorting breaks)\n  a === null ? a = '' : null;\n  b === null ? b = '' : null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'string' && typeof b === 'string') {\n    return compareStrings(a, b, locale);\n  }\n\n  // if column has React elements, this should sort by the child string if there is one\n  if (typeof a === 'object' && typeof b === 'object') {\n    var _a$props, _b$props;\n    if (typeof ((_a$props = a.props) === null || _a$props === void 0 ? void 0 : _a$props.children) === 'string' && typeof ((_b$props = b.props) === null || _b$props === void 0 ? void 0 : _b$props.children) === 'string') {\n      return compareStrings(a.props.children, b.props.children, locale);\n    }\n  }\n  return compareStrings('' + a, '' + b, locale);\n};\n\n/**\n * Use the built-in `localeCompare` function available on strings to compare two\n * strings.\n *\n * @param {string} a\n * @param {string} b\n * @param {string} locale\n * @returns {number}\n */\nconst compareStrings = function (a, b) {\n  let locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n  // Only set `numeric: true` if the string only contains numbers\n  // https://stackoverflow.com/a/175787\n  if (!isNaN(a) && !isNaN(parseFloat(a)) && !isNaN(b) && !isNaN(parseFloat(b))) {\n    return a.localeCompare(b, locale, {\n      numeric: true\n    });\n  }\n  return a.localeCompare(b, locale);\n};\n\n/**\n * Default implementation of how we sort rows internally. The idea behind this\n * implementation is to use the given list of row ids to look up the cells in\n * the row by the given key. We then use the value of these cells and pipe them\n * into our local `compareStrings` method, including the locale where\n * appropriate.\n *\n * @param {object} config\n * @param {Array[string]} config.rowIds array of all the row ids in the table\n * @param {object} config.cellsById object containing a mapping of cell id to\n * cell\n * @param {string} config.key the header key that we use to lookup the cell\n * @param {string} [config.locale] optional locale used in the comparison\n * function\n * @param {string} config.sortDirection the sort direction used to determine the\n * order the comparison is called in\n * @param {Function} config.sortRow\n * @returns {Array[string]} array of sorted rowIds\n */\nconst sortRows = _ref => {\n  let {\n    rowIds,\n    cellsById,\n    sortDirection,\n    key,\n    locale = 'en',\n    sortRow = defaultSortRow\n  } = _ref;\n  return rowIds.slice().sort((a, b) => {\n    const cellA = cellsById[getCellId(a, key)];\n    const cellB = cellsById[getCellId(b, key)];\n    return sortRow(cellA && cellA.value, cellB && cellB.value, {\n      key,\n      sortDirection,\n      locale,\n      sortStates,\n      compare,\n      rowIds: [a, b]\n    });\n  });\n};\nconst defaultSortRow = (cellA, cellB, _ref2) => {\n  let {\n    sortDirection,\n    sortStates,\n    locale\n  } = _ref2;\n  if (sortDirection === sortStates.ASC) {\n    return compare(cellA, cellB, locale);\n  }\n  return compare(cellB, cellA, locale);\n};\nexport { compare, compareStrings, defaultSortRow, sortRows };","map":{"version":3,"names":["getCellId","sortStates","compare","a","b","locale","arguments","length","undefined","compareStrings","_a$props","_b$props","props","children","isNaN","parseFloat","localeCompare","numeric","sortRows","_ref","rowIds","cellsById","sortDirection","key","sortRow","defaultSortRow","slice","sort","cellA","cellB","value","_ref2","ASC"],"sources":["/Users/davidguan/Local Sites/e/app/public/wp-content/plugins/drhaiel/ls_uhcc_bot_fe/node_modules/@carbon/react/es/components/DataTable/tools/sorting.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { getCellId } from './cells.js';\nimport { sortStates } from '../state/sortStates.js';\n\n/**\n * Compare two primitives to determine which comes first. Initially, this method\n * will try and figure out if both entries are the same type. If so, it will\n * apply the default sort algorithm for those types. Otherwise, it defaults to a\n * string conversion.\n *\n * @param {number|string} a\n * @param {number|string} b\n * @param {string} locale\n * @returns {number}\n */\nconst compare = function (a, b) {\n  let locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n  // prevent multiple null values in one column (sorting breaks)\n  a === null ? a = '' : null;\n  b === null ? b = '' : null;\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'string' && typeof b === 'string') {\n    return compareStrings(a, b, locale);\n  }\n\n  // if column has React elements, this should sort by the child string if there is one\n  if (typeof a === 'object' && typeof b === 'object') {\n    if (typeof a.props?.children === 'string' && typeof b.props?.children === 'string') {\n      return compareStrings(a.props.children, b.props.children, locale);\n    }\n  }\n  return compareStrings('' + a, '' + b, locale);\n};\n\n/**\n * Use the built-in `localeCompare` function available on strings to compare two\n * strings.\n *\n * @param {string} a\n * @param {string} b\n * @param {string} locale\n * @returns {number}\n */\nconst compareStrings = function (a, b) {\n  let locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';\n  // Only set `numeric: true` if the string only contains numbers\n  // https://stackoverflow.com/a/175787\n  if (!isNaN(a) && !isNaN(parseFloat(a)) && !isNaN(b) && !isNaN(parseFloat(b))) {\n    return a.localeCompare(b, locale, {\n      numeric: true\n    });\n  }\n  return a.localeCompare(b, locale);\n};\n\n/**\n * Default implementation of how we sort rows internally. The idea behind this\n * implementation is to use the given list of row ids to look up the cells in\n * the row by the given key. We then use the value of these cells and pipe them\n * into our local `compareStrings` method, including the locale where\n * appropriate.\n *\n * @param {object} config\n * @param {Array[string]} config.rowIds array of all the row ids in the table\n * @param {object} config.cellsById object containing a mapping of cell id to\n * cell\n * @param {string} config.key the header key that we use to lookup the cell\n * @param {string} [config.locale] optional locale used in the comparison\n * function\n * @param {string} config.sortDirection the sort direction used to determine the\n * order the comparison is called in\n * @param {Function} config.sortRow\n * @returns {Array[string]} array of sorted rowIds\n */\nconst sortRows = _ref => {\n  let {\n    rowIds,\n    cellsById,\n    sortDirection,\n    key,\n    locale = 'en',\n    sortRow = defaultSortRow\n  } = _ref;\n  return rowIds.slice().sort((a, b) => {\n    const cellA = cellsById[getCellId(a, key)];\n    const cellB = cellsById[getCellId(b, key)];\n    return sortRow(cellA && cellA.value, cellB && cellB.value, {\n      key,\n      sortDirection,\n      locale,\n      sortStates,\n      compare,\n      rowIds: [a, b]\n    });\n  });\n};\nconst defaultSortRow = (cellA, cellB, _ref2) => {\n  let {\n    sortDirection,\n    sortStates,\n    locale\n  } = _ref2;\n  if (sortDirection === sortStates.ASC) {\n    return compare(cellA, cellB, locale);\n  }\n  return compare(cellB, cellA, locale);\n};\n\nexport { compare, compareStrings, defaultSortRow, sortRows };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}