{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport findLast from 'lodash.findlast';\nimport { useEffect } from 'react';\nimport { DOCUMENT_POSITION_BROAD_PRECEDING, selectorTabbable, DOCUMENT_POSITION_BROAD_FOLLOWING } from './keyboard/navigation.js';\nimport { tabbable } from 'tabbable';\n\n/**\n * @param {Node} node A DOM node.\n * @param {string[]} selectorsFloatingMenus The CSS selectors that matches floating menus.\n * @returns {boolean} `true` of the given `node` is in a floating menu.\n */\nfunction elementOrParentIsFloatingMenu(node) {\n  let selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (node && typeof node.closest === 'function') {\n    const allSelectorsFloatingMenus = [\".cds--overflow-menu-options\", \".cds--tooltip\", '.flatpickr-calendar', ...selectorsFloatingMenus];\n    return allSelectorsFloatingMenus.some(selector => node.closest(selector));\n  }\n}\n\n/**\n * Ensures the focus is kept in the given `modalNode`, implementing \"focus-wrap\" behavior.\n * @param {object} options The options.\n * @param {Node|null} options.bodyNode\n * @param {Node|null} options.startTrapNode The DOM node of the focus sentinel the is placed earlier next to `modalNode`.\n * @param {Node|null} options.endTrapNode The DOM node of the focus sentinel the is placed next to `modalNode`.\n * @param {Node} options.currentActiveNode The DOM node that has focus.\n * @param {Node} options.oldActiveNode The DOM node that previously had focus.\n * @param {string[]} [options.selectorsFloatingMenus] The CSS selectors that matches floating menus.\n */\nfunction wrapFocus(_ref) {\n  let {\n    bodyNode,\n    startTrapNode,\n    endTrapNode,\n    currentActiveNode,\n    oldActiveNode,\n    selectorsFloatingMenus\n  } = _ref;\n  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {\n    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);\n    if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {\n      const tabbable = findLast(bodyNode.querySelectorAll(selectorTabbable), elem => Boolean(elem.offsetParent));\n      if (tabbable) {\n        tabbable.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {\n      const tabbable = Array.prototype.find.call(bodyNode.querySelectorAll(selectorTabbable), elem => Boolean(elem.offsetParent));\n      if (tabbable) {\n        tabbable.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    }\n  }\n}\n\n/**\n * Ensures the focus is kept in the given `containerNode`, implementing \"focus-wrap\" behavior.\n * Note: This must be called *before* focus moves using onKeyDown or similar.\n * @param {object} options The options.\n * @param {Node|null} options.containerNode\n * @param {EventTarget} options.currentActiveNode The DOM node that has focus.\n * @param {KeyboardEvent} options.event The DOM event\n */\nfunction wrapFocusWithoutSentinels(_ref2) {\n  let {\n    containerNode,\n    currentActiveNode,\n    event\n  } = _ref2;\n  if (['blur', 'focusout', 'focusin', 'focus'].includes(event.type) && process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      throw new Error(\"Error: wrapFocusWithoutSentinels(...) called in unsupported \".concat(event.type, \" event.\\n\\nCall wrapFocusWithoutSentinels(...) from onKeyDown instead.\"));\n    });\n  }\n\n  // The reason we're using tabbable is because it returns the tabbable\n  // items *in tab order*, whereas using our `selectorTabbable` only\n  // returns in DOM order\n  const tabbables = tabbable(containerNode);\n  const firstTabbable = tabbables[0];\n  const lastTabbable = tabbables[tabbables.length - 1];\n\n  // console.log(`---------------------------------`);\n  // console.log(containerNode);\n  // console.log(tabbables);\n  // console.log(firstTabbable);\n  // console.log(lastTabbable);\n  // console.log(currentActiveNode);\n\n  // The shift key is used to determine if focus is moving forwards or backwards\n  if (currentActiveNode === lastTabbable && !event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    firstTabbable.focus();\n  }\n  if (currentActiveNode === firstTabbable && event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    lastTabbable.focus();\n  }\n}\nexport { wrapFocus as default, elementOrParentIsFloatingMenu, wrapFocusWithoutSentinels };","map":{"version":3,"names":["findLast","useEffect","DOCUMENT_POSITION_BROAD_PRECEDING","selectorTabbable","DOCUMENT_POSITION_BROAD_FOLLOWING","tabbable","elementOrParentIsFloatingMenu","node","selectorsFloatingMenus","arguments","length","undefined","closest","allSelectorsFloatingMenus","some","selector","wrapFocus","_ref","bodyNode","startTrapNode","endTrapNode","currentActiveNode","oldActiveNode","contains","comparisonResult","compareDocumentPosition","querySelectorAll","elem","Boolean","offsetParent","focus","Array","prototype","find","call","wrapFocusWithoutSentinels","_ref2","containerNode","event","includes","type","process","env","NODE_ENV","Error","concat","tabbables","firstTabbable","lastTabbable","shiftKey","preventDefault","default"],"sources":["/Users/davidguan/Local Sites/e/app/public/wp-content/plugins/drhaiel/ls_uhcc_bot_fe/node_modules/@carbon/react/es/internal/wrapFocus.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport findLast from 'lodash.findlast';\nimport { useEffect } from 'react';\nimport { DOCUMENT_POSITION_BROAD_PRECEDING, selectorTabbable, DOCUMENT_POSITION_BROAD_FOLLOWING } from './keyboard/navigation.js';\nimport { tabbable } from 'tabbable';\n\n/**\n * @param {Node} node A DOM node.\n * @param {string[]} selectorsFloatingMenus The CSS selectors that matches floating menus.\n * @returns {boolean} `true` of the given `node` is in a floating menu.\n */\nfunction elementOrParentIsFloatingMenu(node) {\n  let selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (node && typeof node.closest === 'function') {\n    const allSelectorsFloatingMenus = [`.cds--overflow-menu-options`, `.cds--tooltip`, '.flatpickr-calendar', ...selectorsFloatingMenus];\n    return allSelectorsFloatingMenus.some(selector => node.closest(selector));\n  }\n}\n\n/**\n * Ensures the focus is kept in the given `modalNode`, implementing \"focus-wrap\" behavior.\n * @param {object} options The options.\n * @param {Node|null} options.bodyNode\n * @param {Node|null} options.startTrapNode The DOM node of the focus sentinel the is placed earlier next to `modalNode`.\n * @param {Node|null} options.endTrapNode The DOM node of the focus sentinel the is placed next to `modalNode`.\n * @param {Node} options.currentActiveNode The DOM node that has focus.\n * @param {Node} options.oldActiveNode The DOM node that previously had focus.\n * @param {string[]} [options.selectorsFloatingMenus] The CSS selectors that matches floating menus.\n */\nfunction wrapFocus(_ref) {\n  let {\n    bodyNode,\n    startTrapNode,\n    endTrapNode,\n    currentActiveNode,\n    oldActiveNode,\n    selectorsFloatingMenus\n  } = _ref;\n  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {\n    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);\n    if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {\n      const tabbable = findLast(bodyNode.querySelectorAll(selectorTabbable), elem => Boolean(elem.offsetParent));\n      if (tabbable) {\n        tabbable.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {\n      const tabbable = Array.prototype.find.call(bodyNode.querySelectorAll(selectorTabbable), elem => Boolean(elem.offsetParent));\n      if (tabbable) {\n        tabbable.focus();\n      } else if (bodyNode !== oldActiveNode) {\n        bodyNode.focus();\n      }\n    }\n  }\n}\n\n/**\n * Ensures the focus is kept in the given `containerNode`, implementing \"focus-wrap\" behavior.\n * Note: This must be called *before* focus moves using onKeyDown or similar.\n * @param {object} options The options.\n * @param {Node|null} options.containerNode\n * @param {EventTarget} options.currentActiveNode The DOM node that has focus.\n * @param {KeyboardEvent} options.event The DOM event\n */\nfunction wrapFocusWithoutSentinels(_ref2) {\n  let {\n    containerNode,\n    currentActiveNode,\n    event\n  } = _ref2;\n  if (['blur', 'focusout', 'focusin', 'focus'].includes(event.type) && process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      throw new Error(`Error: wrapFocusWithoutSentinels(...) called in unsupported ${event.type} event.\\n\\nCall wrapFocusWithoutSentinels(...) from onKeyDown instead.`);\n    });\n  }\n\n  // The reason we're using tabbable is because it returns the tabbable\n  // items *in tab order*, whereas using our `selectorTabbable` only\n  // returns in DOM order\n  const tabbables = tabbable(containerNode);\n  const firstTabbable = tabbables[0];\n  const lastTabbable = tabbables[tabbables.length - 1];\n\n  // console.log(`---------------------------------`);\n  // console.log(containerNode);\n  // console.log(tabbables);\n  // console.log(firstTabbable);\n  // console.log(lastTabbable);\n  // console.log(currentActiveNode);\n\n  // The shift key is used to determine if focus is moving forwards or backwards\n  if (currentActiveNode === lastTabbable && !event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    firstTabbable.focus();\n  }\n  if (currentActiveNode === firstTabbable && event.shiftKey) {\n    // Cancel the current movement of focus because we're going to place it ourselves\n    event.preventDefault();\n    lastTabbable.focus();\n  }\n}\n\nexport { wrapFocus as default, elementOrParentIsFloatingMenu, wrapFocusWithoutSentinels };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}